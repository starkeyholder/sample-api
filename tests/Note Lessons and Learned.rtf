{\rtf1\ansi\ansicpg1252\cocoartf2822
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\froman\fcharset0 Times-Roman;\f1\fmodern\fcharset0 Courier;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\margl1440\margr1440\vieww27000\viewh13500\viewkind0
\deftab720
\pard\pardeftab720\sa240\partightenfactor0

\f0\fs24 \cf0 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 I spent some time at the beginning going back and forth between the basic 
\f1\fs26 \strokec2 test_health_check
\f0\fs24 \strokec2  example and the pytest documentation link (that in README page). At first, it wasn\'92t obvious how everything fit together \'97 especially how fixtures work, how 
\f1\fs26 \strokec2 client.get()
\f0\fs24 \strokec2  simulates an HTTP request, and the importance of the 
\f1\fs26 \strokec2 client
\f0\fs24 \strokec2  parameter in each test function. I initially didn\'92t pay enough attention to how 
\f1\fs26 \strokec2 client
\f0\fs24 \strokec2  was being injected into each test.\
After experimenting and re-reading the examples a few times, things started to click. Once I understood the overall pattern, writing additional tests became much more straightforward and consistent.\
\pard\pardeftab720\partightenfactor0
\cf0 \strokec2 I learned early on from pytest error output was that I needed a consistent 
\f1\fs26 \strokec2 users_db
\f0\fs24 \strokec2  dictionary set up for the tests. The failures and tracebacks made it clear when the in-memory database wasn\'92t initialized or was in the wrong state, which led me to explicitly create and reset the 
\f1\fs26 \strokec2 users_db
\f0\fs24 \strokec2  data before each test.\
\
\pard\pardeftab720\sa240\partightenfactor0
\cf0 \strokec2 This is where I spent most of my time. The tests that were failing were:\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sa240\partightenfactor0
\ls1\ilvl0
\f1\fs26 \cf0 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 test_list_users_with_data
\f0\fs24 \
\ls1\ilvl0
\f1\fs26 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 test_list_users_active_only
\f0\fs24 \
\ls1\ilvl0
\f1\fs26 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 test_delete_user_soft_delete
\f0\fs24 \
\pard\pardeftab720\sa240\partightenfactor0
\cf0 \strokec2 Initially, I kept adjusting the tests, assuming I had made a mistake. After stepping back and reviewing the API code more carefully, I realized the issue wasn\'92t with the tests at all \'97 it was in the application logic.\
The check for the 
\f1\fs26 \strokec2 active_only
\f0\fs24 \strokec2  flag was inverted, which caused the API to return incorrect results. Once I fixed that condition, all three tests passed immediately without any changes to the test code.\
\pard\pardeftab720\sa240\partightenfactor0
\cf0 It was a good reminder that when tests fail, it doesn\'92t always mean the tests are wrong \'97 sometimes they\'92re doing exactly what they\'92re supposed to do by exposing a bug in the implementation. At the same time, it reminded me to slow down and double-check my own thinking in the test cases, just to make sure the test logic itself makes sense and is validating the right behavior.\
\pard\pardeftab720\partightenfactor0
\cf0 \strokec2 \
\
\
\
}